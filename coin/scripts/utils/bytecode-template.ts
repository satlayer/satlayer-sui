// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

import {bcs, BcsReader, BcsWriter } from "@mysten/bcs";

/**
 * Rust representation of the compiled module; generated by the
 * `deserialize` call in the Wasm module.
 */
export interface MoveCompiledModule {
  version: number;
  self_module_handle_idx: number;
  module_handles: {
    address: number;
    name: number;
  }[];
  struct_handles: {
    name: number;
  }[];
  function_handles: {
    module: number;
    name: number;
    parameters: number;
    return_: number;
    type_parameters: number[];
  }[];
  field_handles: {
    name: number;
    // more fields
  };
  friend_decls: []; // TODO!
  struct_def_instantiations: []; // TODO!
  function_instantiations: {
    handle: number;
    type_parameters: number;
  }[];
  field_instantiations: []; // TODO!
  signatures: []; // TODO!
  /**
   * The list of the identifiers in the bytecode.
   * Is referenced by:
   * - module_handles
   * - field_handles
   * - function_handles
   * - struct_handles
   *
   * Identifiers must be sorted by the char code or the resulting
   * bytecode won't be usable on chain as a dependency.
   */
  identifiers: string[];
  address_identifiers: string[];
  constant_pool: {
    type_: string;
    data: number[];
  }[];
  metadata: []; // TODO!
  struct_defs: {
    struct_handle: number;
    field_information: {
      Declared: {
        name: number;
        signature: {
          Struct: number;
        };
      }[];
    };
  }[];
  function_defs: {
    function: number;
    visibility: "Private" | "Public";
    is_entry: boolean;
    acquires_global_resources: [];
    code: {
      locals: number;
      code: any[]; // TODO!
    }[];
  };
}

/**
 * Helper class which wraps the underlying JSON structure.
 * Provides a way to change the identifiers and update the identifier indexes.
 */
export class CompiledModule {
  constructor(public inner: MoveCompiledModule) {}

  /**
   * Quite dangerous method which updates a constant in the constant pool. To make sure
   * that the index is set correctly, the `expectedValue` and `expectedType` must be provided
   * - this way we at least try to minimize the risk of updating a wrong constant.
   */
  updateConstant(
    idx: number,
    value: string,
    expectedValue: string,
    expectedType: string
  ) {
    if (idx >= this.inner.constant_pool.length) {
      throw new Error(
        "Invalid constant index; no constant exists at this index"
      );
    }

    let { type_, data } = this.inner.constant_pool[idx];
    type_ =
      JSON.stringify(type_) == JSON.stringify({ Vector: "U8" })
        ? "string"
        : type_;

    if (expectedType.toLowerCase() !== type_.toLowerCase()) {
      throw new Error(
        `Invalid constant type; expected ${expectedType}, got ${type_}`
      );
    }

    //let oldValue = bcs.de(type_.toLowerCase(), new Uint8Array(data)).toString();
    let oldValue = bcs.string().parse(new Uint8Array(data)); 

    if (oldValue !== expectedValue) {
      throw new Error(
        `Invalid constant value; expected ${expectedValue}, got ${oldValue}`
      );
    }

    this.inner.constant_pool[idx].data = [
      //...bcs.ser(type_.toLowerCase(), value).toBytes(),
      ...bcs.string().serialize(value).toBytes(),

    ];

    return this;
  }

  /**
   * Update `identifiers`: provide the changeset where keys are the old
   * identifiers and values are the new identifiers.
   */
  changeIdentifiers(identMap: Record<string, string>): CompiledModule {
    // first apply patches - they don't affect indexes; but we need to keep
    // them to compare agains the new sorting order later.
    let identifiers = Object.freeze(
      [...this.inner.identifiers].map((ident) =>
        ident in identMap ? identMap[ident] : ident
      )
    );

    // sort the identifiers - indexes are changed.
    this.inner.identifiers = [...identifiers].sort(
      (a, b) => a.charCodeAt(0) - b.charCodeAt(0)
    );

    // console.log(this.inner.identifiers, identifiers);

    let indexUpdates = new Map();
    for (let ident of identifiers) {
      let oldIdx = identifiers.indexOf(ident);
      let newIdx = this.inner.identifiers.indexOf(ident);
      indexUpdates.set(oldIdx, newIdx);
    }

    const keys = [
      "module_handles",
      "struct_handles",
      "function_handles",
      "field_handles",
    ];

    // update each of the storages with the new index.
    for (let innerKey of keys) {
      // @ts-ignore
      this.inner[innerKey] = this.inner[innerKey].map((handle) => {
        return indexUpdates.has(handle.name)
          ? { ...handle, name: indexUpdates.get(handle.name) }
          : handle;
      });
    }

    // separately patch struct defs
    this.inner.struct_defs = this.inner.struct_defs.map((struct) => {
      let decl = struct.field_information.Declared.map((decl) => ({
        ...decl,
        name: indexUpdates.get(decl.name),
      }));

      return {
        ...struct,
        field_information: { Declared: decl },
      };
    });

    return this;
  }

  toJSON() {
    return this.inner;
  }
}

export function getByteCode() {
  return "a11ceb0b060000000a01000c020c1e032a33045d0c05696d07d601d10108a70360068704310ab804050cbd044e0011010c02060212021302140002020001010701000002000c01000102030c01000104040200050507000009000100000702030102010b010b010001100d0b010002070e0f0102030d0d01010c030e0801010c040f050600050a0c0a0001040607020a030a040d051002080007080400020900070804010b03010900010800010608040105010b0301080002090005040b010108050b010108050b020109000b03010900010805010b01010900010a02010900070900020a020a020a020b01010805070804020b030109000b02010900010b020109000c436f696e4d65746164617461064f7074696f6e0854454d504c4154450b5472656173757279436170095478436f6e746578740355726c04636f696e0f6372656174655f63757272656e63790b64756d6d795f6669656c6404696e6974156e65775f756e736166655f66726f6d5f6279746573046e6f6e65066f7074696f6e147075626c69635f667265657a655f6f626a6563740f7075626c69635f7472616e736665720673656e64657204736f6d650874656d706c617465087472616e736665720a74785f636f6e746578740375726c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020a02070653796d626f6c0a0205044e616d650a020c0b4465736372697074696f6e0a02090849636f6e5f75726c0a02010000020108010000000001080b000a0138000b012e110738010201000000091b0703070421040738020c02050b0703110838030c020b020c030b0031090700070107020b030b0138040c040c050b0438050b050200";
}